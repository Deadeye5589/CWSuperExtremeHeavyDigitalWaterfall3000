/*
 * WasserfallTreiber.c
 *
 * Created: 21.03.2019 11:00:53
 * Author : Ich
 */ 


// Defines ---------------------------------------------------------
#define BUFFER_SIZE				2		//Size of the UART Rx ring buffer
#define DRV8860DELAY			4		//Delay in us for DRV8860 drivers
#define F_CPU 32000000UL				//CPU frequency generated by internal clock

// Include headers ---------------------------------------------------------
#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include "ringbuffer.h"

// Global variables ---------------------------------------------------------
uint8_t USART_Data[BUFFER_SIZE];		//UART Rx ring buffer
RingBuffer_t Buffer;					//Construction of ringerbuffer struct


// definition of functions ---------------------------------------------------------
// function name: init_ports()
// configuration of port pins
void init_ports(void){
	PORTC.DIRSET = (1<<PORT7) | (1<<PORT3) | (1<<PORT0);				//Set PC7, PC3 and PC0 as output
	PORTCFG.CLKEVOUT = PORTCFG_CLKOUT_PC7_gc;							//Route clock to PC7 output
	PORTD.DIRSET = (1<<PORT6) | (1<<PORT4) | (1<<PORT3) | (1<<PORT1);	//Out for DRV8860 Enable, Data Out, Clock and Latch
	PORTD.DIRSET = (1<<PORT7) | (1<<PORT6) | (1<<PORT5) | (1<<PORT4);	//Hardware SPI alternative for DRV8860 control 
}

// function name: init_clocks()
// Activates the external 16 MHz crystal
// Uses internal PLL to generate 32 MHz main clock frequency
void init_clocks(void){
	OSC.CTRL |= OSC_RC32MEN_bm | OSC_RC32KEN_bm;  // Enable the internal 32MHz & 32KHz oscillators
	while(!(OSC.STATUS & OSC_RC32KRDY_bm));       // Wait for 32Khz oscillator to stabilize
	while(!(OSC.STATUS & OSC_RC32MRDY_bm));       // Wait for 32MHz oscillator to stabilize
	DFLLRC32M.CTRL = DFLL_ENABLE_bm ;             // Enable DFLL - defaults to calibrate against internal 32Khz clock
	CCP = CCP_IOREG_gc;                           // Disable register security for clock update
	CLK.CTRL = CLK_SCLKSEL_RC32M_gc;              // Switch to 32MHz clock
	OSC.CTRL &= ~OSC_RC2MEN_bm;                   // Disable default 2Mhz oscillator
}

// function name: init_uart()
// Configure UART to 115200 Baud 8N1 format
// Use Rx and Tx, Rx interrupt based
// with CLK2X = 0, BSCALE = -6 error <0,01%, BSEL = 1047
void init_uart(void){
	USARTC0.BAUDCTRLA = 0x417 & 0x0FF;											//Write lower 8 bits of BSEL to RegA
	USARTC0.BAUDCTRLB = ((0x417 & 0xF00) >> 0x08);								//Write higher 4 bits of BSEL to RegB
	USARTC0.BAUDCTRLB |= ((-6 & 0x0F) << 0x04);									//Write BSCALE to bit 4...7 of RegB 
	USARTC0.CTRLA = USART_RXCINTLVL_LO_gc;										//Enable receive interrupt with low priority
	USARTC0.STATUS |= USART_RXCIF_bm;											//Clear interrupt flag to have clean start condition
	USARTC0.CTRLB = USART_TXEN_bm | USART_RXEN_bm;								//Enable Tx and Rx for UART on PortC
	USARTC0.CTRLC = USART_CHSIZE_8BIT_gc;										//Define databyte to be 8 bits
	USARTC0.CTRLC &= ~(USART_PMODE0_bm | USART_PMODE1_bm | USART_SBMODE_bm);	//Set to 8N1 Mode
}

// function name: init_spi_uart()
// Configure UART be used as SPI interface
// Use Tx only with 250 kBit / s
void init_spi_uart(void){
	USARTD0.CTRLB = USART_TXEN_bm;			//Enable transmitter of UART at Port D
	USARTD0.CTRLC = USART_CMODE_MSPI_gc;	//SPI mode 0 CPOL and CPHA at 0
	USARTD0.BAUDCTRLA = 0x3F;				//BSEL = 63 for 250 kBit / s 
}


// function name: DRV8860_send_data()
// send out 8 bits of data to DRV8860 driver
// Software driver for bit banging
// Not nescessary for Gehirn V1.0 PCB
void DRV8860_send_data(uint8_t drv8860_data){
	uint8_t i = 0;
	PORTD.OUTCLR = PIN1_bm;  //Clock Low
	for (i=8; i!=0; i--)	 //Send out byte
	{
		/*
		set data out port accordingly to current bit status to either high or low
		*/
		if (drv8860_data&0x80)
		{
			PORTD.OUTSET = PIN2_bm;
		} 
		else
		{
			PORTD.OUTCLR = PIN2_bm;
		}
		_delay_us(DRV8860DELAY);				//Delay 4us
		PORTD.OUTSET = PIN1_bm;					//Clock High
		drv8860_data = (drv8860_data<<1);		//Shift to next bit position of byte
		_delay_us(DRV8860DELAY);				//Delay 4us
		/* 
		left CLK HIGH at after the last data transfered
		avoid unwanted fault register pushed out.
		*/
		if (i > 1)
		{
			PORTD.OUTCLR = PIN1_bm;				//Clock Low
		}	
	}
}


// function name: DRV8860_cleanup()
// Clean registers of DRV8860 to avoid unwanted fault register pushed out
// Call with number of drivers that are used for the waterfall
// Each driver has 8 channels that will be cleared during startup
void DRV8860_cleanup(uint16_t no_of_drivers){
	//set all outputs to low
	PORTD.OUTSET = PIN4_bm;									//Latch High
	_delay_us(DRV8860DELAY);								//Delay 4us
	PORTD.OUTCLR = PIN0_bm;									//Latch Low
	for(uint16_t i = 0; i < 8 * no_of_drivers; i++)
	{
		while(!(USARTD0.STATUS & USART_DREIF_bm));			//Wait for transmission buffer to be empty
			USARTD0.DATA = 0;								//Send data to first DRV8860 driver
	}
	_delay_us(DRV8860DELAY);								//Delay 4us
	PORTD.OUTSET = PIN4_bm;									//Latch High
}


// interrupt handlers ---------------------------------------------------------
// function name: UARTC0_Rx_Interrupt
// UART Receive interrupt to write received data into ring buffer 
// as test also write some data to the DRV8860 
ISR(USARTC0_RXC_vect)
{
 	volatile uint8_t Data = USARTC0.DATA;						//Receive 1 byte from UART
	RingBuffer_Save(&Buffer, Data);								//Store byte into ring buffer
	USARTC0.DATA = Data;										//Send out same byte as mirror per UART
	
	// Send the buffer if it is full
	if(RingBuffer_IsFull(&Buffer))		
	{	
		/*
		Send CR + LF
		*/
		while(!(USARTC0.STATUS & USART_DREIF_bm));
		USARTC0.DATA = 'x';
		while(!(USARTC0.STATUS & USART_DREIF_bm));
		USARTC0.DATA = 0x0D;
		while(!(USARTC0.STATUS & USART_DREIF_bm));
		USARTC0.DATA = 0x0A;
		/*
		Output content of ring buffer on DRV8860 drivers 
		*/	
		PORTD.OUTSET = PIN4_bm;									//Latch High
		_delay_us(DRV8860DELAY);								//Delay 4us
		PORTD.OUTCLR = PIN4_bm;									//Latch Low
		for(uint8_t i = 0; i < BUFFER_SIZE; i++)
		{
			while(!(USARTD0.STATUS & USART_DREIF_bm));			//Wait for transmission buffer to be empty
			USARTD0.DATA = RingBuffer_Load(&Buffer);			//Send data to first DRV8860 driver
		}
		_delay_us(DRV8860DELAY);								//Delay 4us
		PORTD.OUTSET = PIN4_bm;									//Latch High
	}
}


// main programm starts here ---------------------------------------------------------
int main(void)
{
	init_clocks();
	init_ports();
	init_uart();
	
	DRV8860_cleanup(2);										//Initialize DRV8860 drivers 
	
	RingBuffer_Init(&Buffer, USART_Data, BUFFER_SIZE);		//Initialize the ring buffer
	
	PMIC.CTRL = PMIC_LOLVLEN_bm;							//Enable low level interrupts
	sei();													//Global enable of interrupts

	PORTD.OUTSET = PIN6_bm;									//Enable the DRV8860 output stages
	
	char* Data = "Hello, World";							//The formal greeting
    while(*Data)											//As long as the greeting shall be
    {
		while(!(USARTC0.STATUS & USART_DREIF_bm));			//Check that transmission buffer is empty
		USARTC0.DATA = *Data++;								//Send a byte of the formal greeting
    }
	
	/*
		Send CR + LF
	*/
	while(!(USARTC0.STATUS & USART_DREIF_bm));
	USARTC0.DATA = 0x0D;
	while(!(USARTC0.STATUS & USART_DREIF_bm));
	USARTC0.DATA = 0x0A;


	
    /* Replace with your application code */
    while (1) 
    {
		_delay_ms(500);										//basically nop, nop, nop
		PORTC.OUTSET = PIN0_bm;								//Set PC0 to high (LED on)
		_delay_ms(500);										//more of the nop, nop, nop
		PORTC.OUTCLR = PIN0_bm;								//Clear PC0 to low (LED off)
    }
}

